# SqlTuning
업무에 바로 쓰는 SQL튜닝

* 1장. Mysql 과 MariaDB 개요   
* 2장. sql 튜닝 용어를 직관적으로 이해하기   
* 3장. sql 튜닝의 실행계획 파헤치기   
* 4장. 악성 sql 튜닝으로 초보자 탈출하기   
* 5장. 악성 sql 튜닝으로 전문가 되기   

### 1장. Mysql 과 MariaDB 개요 

* Mysql은 1995년 오픈소스로 배포된 무료 DBMS
* 2010년 오라클에 인수되었고 2018.05에 배포된 8.0 버전이 현재 최신 버전이다. (2023.08 기준)
* MYSQL이 오라클에 인수되고, MYSQL 핵심개발자 주도로 오픈소스(무료)정책을 지향하는 MariaDB가 탄생함.
* Mysql, MariaDB간 차이는 거의없다. MariaDB 는 현재 11.0 버전까진 나옴.

**1.1 현황**   
1. 부각배경 - Mysql은 상용버전(오라클)과 무료버전 2가지가 있음. mariaDB는 완전한 오픈소스 소프트웨어 
2. DB엔진 영향력 - 오픈소스RDBMS의 영향력. mysql이 58%, Postgre 27%, MariaDB 5%
3. mysql 과 mariaDB가 63%에 육박하는 높은 점유율을 가지고 있음.

**1.2 상용 RDBMS(오라클)와 차이점**
1. 구조적차이
   - 오라클은 서버이중화 시 각각의 DB서버가 하나의 스토리지를 공유한다.
   - MYSQL은 서버이중화 시 각각의 DB서버가 각각의 스토리지를 사용한다.
   - MYSQL은 이중화 시 주로 마스터(주)-슬레이브(종)구조를 사용한다.
   - 마스터노드는 쓰기,읽기 모두 가능. 슬레이브 노드는 읽기만 가능하다.
   - 마스터노드, 슬레이드노드간 동기화 시간차이가 발생하는 경우 조회 시 결과가 다르게 나올 수 있다.
 
   ```
   * 쿼리 오프로딩
   
   - DB서버의 트랜잭션에서 쓰기와 읽기를 각각분리하여 DB 처리량을 늘리는 성능향상 기법
   - 쓰기 트랜잭션 : UPDATE, INSERT, DELETE
   - 읽기 트랜잭션 : SELECT 
   ```
2. MYSQL과 오라클의 지원 기능의 차이
   - 오라클과 MYSQL은 제공하는 조인알고리즘 기능에 차이가 있다.
   - MYSQL 은 대부분 중첩루프조인 방식을 제공
   - 오라클은 그외에 정렬병합조인, 해시조인 방식도 제공한다.
   - (오라클의 조인성능이 더 뛰어나다고 볼 수 있다.)
   - MYSQL은 오라클과 달리 데이터를 저장하는 스토리지 엔진개념을 포함하므로
   - 오픈소스 DBMS를 바로 꽂아서 사용할 수 있는 확장성이 특징이다(?)
   - MYSQL은 오라클 대비 메모리 사용률이 상대적으로 낮아서 비교적 낮은 사양에서도 가능하다.
   - MYSQL은 1MB 메모리 환경에서도 가능하나, 오라클은 최소 수백MB의 환경이 제공되어야 설치가능.

3. MYSQL과 오라클L의 SQL구문의 차이
   - INNULL / NVL
   - LIMIT 5 / ROWNUM <= 5
   - NOW() / SYSDATE
   - IF / DECODE
   - DATE_FORMAT, TO_CHAR
   - SUBSTRING / SUBSTR 등
   - mysql : auto_increment 있다. / 오라클 : 없어서 시퀀스만들어써야함.  
  
4. Mysql SWOT 분석
   - S : 오픈소스(무료), 경량
   - W : 조인알고리즘 부족
   - O : 스토리지 엔진 확장성
   - T : Mysql 라이선스 정책 (오라클에 인수되었으므로 유료화가능성) / MARIADB는 괜찮 ^^
  
### 2장. SQL 튜닝용어를 직관적으로 이해하기

**1. 물리엔진과 오브젝트 용어**
1. DB엔진 용어
   - 스토리지 엔진 (innoDB, MyISAM, MEMORY등) : 디스크나 메모리에서 데이터를 가져오는 역할.
   - innoDB엔진을 주로 사용함. 대량의 쓰기 트랜잭션이 발생하면 MyISAM엔진, 메모리 데이터를 빠르게 읽으려면 MEMORY 엔진을 사용하는 식으로 응용가능.
   - MySQL 엔진 : SQL문의 시작 및 마무리단계에 관여함. sql구문 검사. 스토리지 엔진으로부터 받은 데이터의 불필요 제거, 가공및 연산 담당

2. SQL프로세스 용어
   - < parser 파서 > : MySQL엔진에 포함. SQL문을 쪼개 분리하며 문법검사를 수행.
   - < 전처리기 > : MySQL엔진에 포함. SQL문에 구조적인 문제가없는지 판단.
   - < optimizer 옵티마이저 > : 
   - 옵티마이저는 mysql의 핵심엔진중 하나로 DBMS의 두뇌.
   - 어떤순서로 테이블접근할지, 인덱스 사용여부, 어떤인덱스를 사용할지, 임시테이블을 사용할지 등 전략 수립
   - 실행계획으로 도출할수 있는 경우의 수가 너무 많을때는 시간이 오래걸리므로, 모든 실행계획을 다 판단하지는 않음.
   - 즉 옵티마이저가 선택한 전략이 최상이 실행계획은 아닐 수 도 있음.
   - < 엔진 실행기 > : 옵티마이저에서 수립한 실행 계획을 참고하여 스토리지 엔진으로 부터 데이터를 가져옴.
   - 이후 읽어온 데이터를 정렬, 조인, 필터링등을 진행. MySql엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는
   - 데이터량을 줄이는게 매우 중요함.

3. DB오브젝트 용어
   1. 테이블
   2. 로우(행)
   3. 기본키
      - 기본키(PK)는 특정행을 대표하는 열. 기본키는 인덱스 역할도 하므로, 기본키를 활용해 인덱싱도 가능.
      - mysql에서 기본키는 클러스터형 인덱스로 작동한다. 기본키의 구성열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓이므로
      - 비슷한 기본 키값들은 근거리에 저장된다. 기본키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근 할 수 있다.
        
        ```
        * 기본키 인덱스 주의사항.
   
        기본키와 똑같은 인덱스를 생성하면 인덱스가 저장되는 물리적 공간 낭비와 인덱스 정렬의 오버헤드가 발생함.
        기본적으로 PK 순으로 정렬되어 있기 때문에 PK로는 인덱스를 만들 필요가없다.
   
        CREATE TABLE MEMBER (
           ID INT(11) NOT NULL,
           NAME VARCHAR(14) NOT NULL
           PRIMARY KEY (ID),
           INDEX_I_ID (ID)
        )
        ```
     
   **b. 인덱스**
      - 모든 데이터를 처음부터 끝까지 전부 차례로 검색하는 비효율적인 방식을 개선하기위해 인덱스가 필요.
      - 책의 목차와 비슷하다고 볼 수 있음. 인덱스를 사용하면 원하는 페이지를 빠르게 찾을 수 있다.
      - 특정 컬럼을 인덱스로 지정하면, 해당 컬럼 기준으로 정렬된 인덱스가 추가로 생성된다.
      - 인덱스는 추가로 메모리를 할당하여 생성되고, 인덱스컬럼이 입력, 수정, 삭제가 될때마다 인덱스도 재정렬을 해야하므로
      - 인덱스를 무분별하게 남발하면 자원낭비가 발생할 수 있다. 
  
        ```
        * 인덱스의 예시.
   
        1. 학생테이블에서 기본키로 (학번)이 있고 (이름)에 인덱스를 부여한 경우.
        2. 학생테이블의 실제 데이터는 기본키(학번) 순으로 쌓임. 
        3. 학생 테이블의 (이름)인덱스는 이름 컬럼 기준으로 정렬되어 생성된다..
   
        학생 테이블 (학번(pk) 순으로 쌓임.)
        ----------------------
        학번  이름
        ----------------------
        10001 홍길동
        10002 신사임당
        10003 이순신
        ...
        10999 유관순
   
        이름 인덱스 (이름순으로 나열되어있고 해당 학생의 위치(학번)정보를 가지고 있음)
        ----------------------
        이름     위치
        ----------------------
        강감찬   23129 
        신사임당 10002
        유관순   10999
        이순신   10003
        ...
        홍길동   10001
   
        * 이름으로 검색 시 이름순으로 정렬된 인덱스를 활용하여 위치(학번)을 빠르게 확인 가능
        ```

   **c. 고유 인덱스와 비고유 인덱스**
      - 고유인덱스(UNIQUE_INDEX) : 말그대로 인덱스를 구성하는 열들의 데이터가 유일한것을 의미 (중복불가)
      - 기본키(PK)와 고유인덱스의 차이 : 특성과 목적이 비슷하지만, 고유인덱스는 null이 가능한것이 차이점.
      - 비고유 인덱스 : 중복을 허용하는 인덱스

        ```
        * 고유 인덱스 생성 쿼리
        ALTER TABLE 학생 ADD UNIQUE INDEX 연락처_인덱스(연락처);
   
        * 인덱스 생성 쿼리
        ALTER TABLE 학생 ADD INDEX 이름_인덱스(이름);
        ```

   **d. 뷰**
      - 뷰는 가상의 테이블
      - 학생테이블을 바라보는 학생뷰를 생성 할 경우 뷰에서는 여러 컬럼중 학번과 이름만 노출 시킬 수 있다. 
      - 뷰를 사용하는 이유 : 테이블에서 일부 데이터만 공개하고 노출에 민감한 데이터는 제약을 설정할 수 있는 보안성 때문.
      - 또한 여러개의 테이블을 병합(JOIN)한 성능고려 최적화된 뷰를 생성하여 사용할 경우 일관된 성능을 제공가능.

        ```
        * 뷰 생성 쿼리
        CREATE VIEW 학생_뷰 AS
        SELECT 학번,이름
        FROM 학생;
        ```
5. 논리적인 SQL 용어
   - 
   
